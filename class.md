

## 类 & 对象

包含对象所需的数据，以及描述用户与数据交互所需的操作。

成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 ::** 来定义。在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。

类的成员名和方法的参数名不能相同，建议成员名加上 'm' 前缀或者末尾加上 '_'。[CPP353]

### 类访问修饰符

- public：公有成员在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值。
- private：私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员（派生类也不能访问）。

- protected：保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

### 继承
- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- protected 成员可以被派生类访问。

### 构造函数与析构函数
```C++
class Line
{
	private:
	double length;
	
	public:
		void setLength(double len);
		Line(double len); //构造函数的名称与类的名称完全相同。不会返回任何类型，也不会返回void，常用于赋初值
		~Line();  //析构函数，函数名与类完全相同，只是在前面加了一个波浪号（~）作为前缀，它不会返回任何值，也不会返回void，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
		void Line::getLength(void)  //方法可以定义在类中
        {
			return length;
		}
}

Line::Line(double len) //方法也可以通过范围解析运算符定义在类外，这是构造函数的具体实现，注意函数前无类型
{
	cout << "Object is being created, length = " << len << endl;
	length = len; //初始化属性
}

Line::~Line(void)
{
	cout << "Object is being deleted" << endl;
}

```
也可以使用初始化列表来初始属性
```C++
Line::Line( double len): length(len)
{
    cout << "Object is being created, length = " << len << endl;
}

```
```C++
// 同时初始化多个值
Person::Person( double name, double age, double job): Name(name), Age(age), Job(job)  
//将参数 name, age, job 初始化给属性 Name, Age, Job
{
  ....
}
```
构造函数不同于类方法，因为它创建新的对象，而其他类对象只是被现有的类调用。这是构造函数不能被继承的原因之一。 继承意味着派生类继承基类的成员函数和成员变量，然而，在构造函数完成其工作之前，对象并不存在。

一定要使用显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类即使它不需要析构函数，也应提供一个虚析构函数。

初始化派生类把基类中所有的成员继承过来，除了构造函数和析构函数。友元函数不属于类，它只是给类开了一个后门，自然不能被继承。子类继承父类，那么默认的，就是继承了父类的成员函数和成员变量。
初始化子类时，会先自动调用父类的构造函数，然后才调用子类的构造函数。
析构时，按相反顺序进行。
构造从类层次的最根处开始，在每一层中，首先调用基类的构造函数，然后调用成员对象的构造函数。析构则严格按照与构造相反的次序执行，该次序是唯一的，否则编译器将无法自动执行析构过程。
【CPP524，525，527】

### 拷贝（复制）构造函数

```C++
class Line
{
    public:
    	Line(int len);  //构造函数
    	Line(const Line &obj);  //拷贝构造函数
    	~Line();  //  析构函数
    
    private:
    	int *ptr;
}

// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}
 
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
 
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
```
#### 必须定义拷贝构造函数的情况：
只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源，这两种情况下都必须定义拷贝构造函数。

#### 什么情况使用拷贝构造函数：
类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：
- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

### 友元函数
类的友元函数是定义在类外部，但与成员函数有相同的权限，所以可以访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。  
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

```C++
class Box
{
	double width;
	public:
		friend void printWidth( Box box );  // printwidth 能够调用 Box类的所有私有（private）成员和保护（protected）成员
		void setWidth( double wid );
};
void printWidth( Box box )  // printWidth() 不是任何类的成员函数
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
```

### 内联函数

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。在类中定义的函数都是内联函数，即使不用 inline 说明符。
引入内联函数的目的是为了解决程序中函数调用的效率问题，因为编译器使用相同的函数代码代替函数调用，对于内联代码，程序无需跳转到另一个位置执行代码，再跳回来。因此内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。如果在程序的多个不同的地方调用内联函数，该程序将包含该内联函数的多个副本。总的来说就是用空间换时间。所以内联函数一般都是1-5行的小函数。关于内联函数可以总结为：

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。在类外定义需要显式内联
使用内联函数不过是向编译器提出一种申请，编译器可以拒绝你的申请。

### const总结

```C++
const Stock & Stock::topval(const Stock & s) const
{......}
//有两只股票，返回价格高的那一只股票【CPP363，365】
```
该函数显式的访问一个对象（参数），又隐式的访问另一个对象（调用的对象），并返回其中一个对象的引用，返回引用表明是返回对象本身，而不是其副本，注意那个&不是返回地址。参数中的const表明，该函数不会修改被显式访问的对象（不会修改参数指针指向的内容）；而括号后的const表明，该函数不会修改被隐式地访问的对象（该类方法Stock::topval()不会修改类里的数据）；最前面的const表明函数的返回值不能被修改。
#### 函数返回引用
返回引用能节省调用拷贝（复制）构造函数生成的副本所需的时间和析构函数删除副本所需的时间。但并不总是可以返回引用，函数不能返回在函数中创建的临时对象的引用，因为当函数结束，临时对象就消失了。
【CPP526】

### this指针
每个成员函数（包含构造函数和析构函数）都有一个this指针，this指针指向调用对象，this是地址，如果要引用调用对象本身，用\*this【CPP364】

### 多态
同一个方法在派生类和基类中的行为是不同的，即方法的行为取决于调用该方法的对象。有两种重要的机制可以实现多态公有继承：

- 在派生类中重新定义基类的方法
- 使用虚方法
【注意】在派生类中重新定义基类的方法，会导致基类方法被隐藏（函数隐藏），这不是重载，重载是一个类中的方法与另一个方法同名，但是参数表不同，这种方法称之为重载方法。

### 虚函数
```C++
/*BrassPlus 是 Brass 的子类， ViewAcct() 是两个类中都有的方法。
由于 bp是父类指针，如果基类不用虚方法那么就会调用基类的 ViewAcct() 方法
若如果在基类中将 ViewAcct() 声明为虚，则 bp->ViewAcct() 根据对象类型（BrassPlus）调用 BrassPlue::ViewAcct()方法*/
BrassPlus ophelia;
Brass * bp;
bp = &ophelia;
bp->ViewAcct();  // 是调用子类还是父类的 ViewAcct() 方法？
```
【CPP503】

### 虚析构函数
```C++
// Employee 是基类，Singer 是派生类
Employee *pe = new Singer;
...
delete pe;  // ~Employee() or ~Singer()?
```
如果基类中的析构函数不是虚的，就只调用对应于指针类型(Employee)的析构函数，但实际中，是想调用派生类的析构函数。如果基类的析构函数是虚的，将调用相应对象类型(Singer)的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以保证正确的析构函数序列被调用。
【CPP501，505】

### 静态联编和动态联编
将源程序中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中由于不支持函数重载，这很容易，在C++中，由于支持函数重载，编译器必须查看函数的参数才知道调用的是哪一个函数。C++在编译过程中就可以完成这种联编，故称为动态联编，又称为早期联编。编译器总是对非虚方法使用静态联编。

然而虚函数使编译器不知道在编译时到底用哪一个函数，因为编译器不知道用户将选择哪种类型的对象，所以编译器必须生成能够在程序运行时选择正确的虚函数的代码，这被称之为动态联编，也被称为晚期联编。
【CPP501】

### 有关虚函数的注意事项
- 构造函数不能是虚函数，创建派生类时，将调用派生类的构造函数而不是基类，然后派生类中的构造函数调用基类的构造函数。
- 析构函数应当是虚函数，除非类不用做基类。即使类不用作基类，通常应给基类提供一个虚析构函数
- 友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数
- 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本
- 如果派生类重新定义函数，将隐藏同名基类方法，这不同于重载
【CPP503，504】

### 纯虚函数

纯虚函数是一种特殊的虚函数，纯虚函数只是一个接口，是让派生类实现细节的，在纯虚函数中也可以定义具体实现，但没意义。包含纯虚函数的类是抽象基类（ABC，abstract base class），它只能作为基类，不能创建对象。可以从抽象基类派生出具体类（普通类），这些类可以创建对象。
```C++
class C
public:
	virtual int f1() = 0;  //函数原型中的 =0 使虚函数成为纯虚函数
	virtual double area() const = 0;  
	virtual ~C() {}
```
【CPP509，510】

### 虚函数、纯虚函数
- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。

