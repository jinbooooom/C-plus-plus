
## 类 & 对象

包含对象所需的数据，以及描述用户与数据交互所需的操作。

成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 ::** 来定义。在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。

类的成员名和方法的参数名不能相同，建议成员名加上 'm' 前缀或者末尾加上 '_'。

【CPP 353】

### 类访问修饰符

- public：公有成员在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值。
- private：私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员（派生类也不能访问）。
- protected：保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

### 封装

封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（称之为类）。

封装的意义在于保护或者防止代码（数据）被无意中破坏。

### 继承

继承主要实现代码重用，节省开发时间。子类可以继承父类的一些东西。

- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- protected 成员可以被派生类访问。

### 多态

同一个方法在派生类和基类中的行为是不同的，即方法的行为取决于调用该方法的对象。有两种重要的机制可以实现多态公有继承：

- 在派生类中重新定义基类的方法
- 使用虚方法

【注意】在派生类中重新定义基类的方法，会导致基类方法被隐藏（函数隐藏），这不是重载，重载是一个类中的方法与另一个方法同名，但是参数表不同，这种方法称之为重载方法。

#### 重载与重写

- 重载（overload）：是指允许存在多个同名函数，而这些函数的参数列表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。与多态无关。
- 重写（overried，覆盖）：是指子类重新定义父类虚函数的方法。与多态有关。

### 构造函数与析构函数

```C++
class Line
{
	private:
	double length;
	
	public:
		void setLength(double len);
		Line(double len); //构造函数的名称与类的名称完全相同。不会返回任何类型，也不会返回void，常用于赋初值
		~Line();  //析构函数，函数名与类完全相同，只是在前面加了一个波浪号（~）作为前缀，它不会返回任何值，也不会返回void，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
		void Line::getLength(void)  //方法可以定义在类中
        {
			return length;
		}
}

Line::Line(double len) //方法也可以通过范围解析运算符定义在类外，这是构造函数的具体实现，注意函数前无类型
{
	cout << "Object is being created, length = " << len << endl;
	length = len; //初始化属性
}

Line::~Line(void)
{
	cout << "Object is being deleted" << endl;
}

```
也可以使用初始化列表来初始属性
```C++
Line::Line( double len): length(len)
{
    cout << "Object is being created, length = " << len << endl;
}

```
```C++
// 同时初始化多个值
Person::Person( double name, double age, double job): Name(name), Age(age), Job(job)  
//将参数 name, age, job 初始化给属性 Name, Age, Job
{
  ....
}
```
构造函数不同于类方法，因为它创建新的对象，而其他类对象只是被现有的类调用。这是构造函数不能被继承的原因之一。 继承意味着派生类继承基类的成员函数和成员变量，然而，在构造函数完成其工作之前，对象并不存在。

一定要使用显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类即使它不需要析构函数，也应提供一个虚析构函数。

初始化派生类把基类中所有的成员继承过来，除了构造函数和析构函数。友元函数不属于类，它只是给类开了一个后门，自然不能被继承。子类继承父类，那么默认的，就是继承了父类的成员函数和成员变量。
初始化子类时，会先自动调用父类的构造函数，然后才调用子类的构造函数。
析构时，按相反顺序进行。
构造从类层次的最根处开始，在每一层中，首先调用基类的构造函数，然后调用成员对象的构造函数。析构则严格按照与构造相反的次序执行，该次序是唯一的，否则编译器将无法自动执行析构过程。
【CPP524，525，527】

### 拷贝（复制）构造函数

```C++
class Line
{
    public:
    	Line(int len);  //构造函数
    	Line(const Line &obj);  //拷贝构造函数
    	~Line();  //  析构函数
    
    private:
    	int *ptr;
}

// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}
 
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
 
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
```
#### 什么情况使用拷贝构造函数
类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：
- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

### 初始化列表

#### 使用初始化列表的原因

初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。
主要是性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，因为使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。

#### 必须使用初始化列表的情况

（只能使用初始化而不能赋值）

除了性能问题之外，有些时候初始化列表是不可或缺的，以下几种情况时必须使用初始化列表：

- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
- 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；
- 没有默认构造函数的类类型（比如构造函数为私有），因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

【总结】当类中含有const常量、reference 成员变量；基类的构造函数都需要初始化列表。

#### 初始化顺序

成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的。

```C++
class foo {
    public:
    int i;
    int j;
    foo(int x): i(x), j(i) {}; // ok, 先初始化i，后初始化j
};
```

再看下面的代码：

```C++
class foo {
    public:
    int i;
    int j;
    foo(int x): j(x), i(j) {} // i值未定义
    /*
    这里 i 的值是未定义。因为虽然 j 在初始化列表里面出现在 i 前面，
    但是 i 先于 j 定义，所以先初始化 i，而i由 j 初始化，
    此时j尚未初始化，所以导致 i 的值未定义。
    一个好的习惯是，按照成员定义的顺序进行初始化。
    */
};
```

[c++中的初始化列表详解](https://blog.csdn.net/lws123253/article/details/80368047)

### 友元函数

类的友元函数是定义在类外部，但与成员函数有相同的权限，所以可以访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。  
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

```C++
class Box
{
	double width;
	public:
		friend void printWidth( Box box );  // printwidth 能够调用 Box类的所有私有（private）成员和保护（protected）成员
		void setWidth( double wid );
};
void printWidth( Box box )  // printWidth() 不是任何类的成员函数
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
```

### 内联函数

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。在类中定义的函数都是内联函数，即使不用 inline 说明符。
引入内联函数的目的是为了解决程序中函数调用的效率问题，因为编译器使用相同的函数代码代替函数调用，对于内联代码，程序无需跳转到另一个位置执行代码，再跳回来。因此内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。如果在程序的多个不同的地方调用内联函数，该程序将包含该内联函数的多个副本。总的来说就是用空间换时间。所以内联函数一般都是1-5行的小函数。关于内联函数可以总结为：

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。在类外定义需要显式内联
使用内联函数不过是向编译器提出一种申请，编译器可以拒绝你的申请。

### const

```C++
const Stock & Stock::topval(const Stock & s) const
{......}
//有两只股票，返回价格高的那一只股票【CPP363，365】
```
该函数显式的访问一个对象（参数），又隐式的访问另一个对象（调用的对象），并返回其中一个对象的引用，返回引用表明是返回对象本身，而不是其副本，注意那个&不是返回地址。参数中的const表明，该函数不会修改被显式访问的对象（不会修改参数指针指向的内容）；而括号后的const表明，该函数不会修改被隐式地访问的对象（该类方法Stock::topval()不会修改类里的数据）；最前面的const表明函数的返回值不能被修改。
#### 函数返回引用
返回引用能节省调用拷贝（复制）构造函数生成的副本所需的时间和析构函数删除副本所需的时间。但并不总是可以返回引用，函数不能返回在函数中创建的临时对象的引用，因为当函数结束，临时对象就消失了。
【CPP526】

#### const总结

**const作用**

- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针和指针常量；
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，说明该成员函数内不能修改成员变量。

**const使用**

```C++
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数、更新常成员变量
    const A *p = &a;            // 常指针
    const A &q = a;             // 常引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量
    char* const p3 = greeting;          // 常指针，指向字符数组变量
    const char* const p4 = greeting;    // 常指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常指针
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

[const](https://www.yuque.com/huihut/interview/readme#q5mvcc)

#### const与指针

指针本身是一个独立的对象，它又可以指向另一个对象。所以指针和const同时使用时，有两种情况：

```cpp
int i = 0;
int *const j = &i;
//指针常量,指向不可变地址的指针，但可以对它指向的内容进行修改。
// 指针j指向i，const修饰指针j本身，
//所以不允许修改j，但可以通过j修改i的值
const int *k = &i;
//常量指针，指向常量的指针，该指针指向的地址里的内容不可变。
// 指针k指向i，const修饰k指向的i，
//所以可以修改k，但不可以通过k修改i的值
int const *p = &i;
//即 const int *p，同上，为常量指针。
//const 修饰离右边最近的那一个，int const *p 等价于 const int *p
//都可以理解为 const 修饰（*p）而不是 p，那么 p 可变,p 指向的值不可变
```

#### const 与 #define

- const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误 。
- 宏定义是直接替换，不会分配内存，存储于程序的代码段中；
  const常量需要进行内存分配

[const（常量）和#define（宏定义）区别](https://www.cnblogs.com/xumaomao/articles/11049541.html)

### 存储类

#### auto

C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 

auto是类型推导，让使用者获得动态语言的使用体验；但是有区别，那就是auto声明的变量类型，你可以不知道，但是编译器一定要知道，这样才不会报错。 

根据初始化表达式自动推断被声明的变量的类型，如：

```cpp
auto a; //报错！a未初始化，编译器推算不出来 a 是什么类型
auto f=3.14;      //double
auto s("hello");  //const char*
auto z = new auto(9); // int*
auto x1 = 5, x2 = 5.0, x3='r';
/*报错！必须是初始化同一类型。
当在同一行中定义多个变量时，编译器只对第一个类型进行推导，
然后用推导出来的类型定义其它变量*/
```

注意：  

- auto不可作为函数的参数：参数要被编译成指令，auto做参数，会不知道要开辟多大的空间。
- auto不可直接用来声明数组：因为不知道要开辟多大空间。

*auto在实际中最常见的优势用法是C++11提供的新式for循环，还有lambda表达式等进行配合使用。看到那地方再记录*

#### static

- 修饰普通变量：修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。(该变量的内存只被分配一次，在下次调用时仍维持上次的值)
- 修饰普通函数：表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
- 修饰成员变量：静态成员变量用来表示唯一的、可共享的成员变量。它可以在同一个类的所有对象中被访问。静态成员变量只有唯一的一份实体。不需要生成对象就可以访问该成员
- 修饰成员函数：静态成员函数使得不需要生成对象就可以访问该函数，静态成员函数不接收 this 指针，不能访问非静态成员。

【对1，2条的总结】

static 最重要的一条在于修饰普通变量与普通函数时，隐藏普通变量与普通函数。因为未加 static 前缀的全局变量和函数都具有全局可见性。

#### extern

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都可见。使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置(定义只有一次，不可重复定义)。 

多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

### this指针

每个非静态成员函数（包含构造函数和析构函数）都有一个`this`指针，`this`指针指向调用对象，`this`是地址，如果要引用调用对象本身，用`*this`。

当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。this 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。

【CPP364】

【注意】静态成员函数里，不能使用 this 指针：

静态成员函数并不是针对某个类的实例对象，而是属于整个类的，为所有的对象实例所共有。他在作用域的范围内是全局的，独立于类的对象之外的。他只对类内部的静态成员变量做操作。当实例化一个类的对象时候，里面不存在静态成员的。this指针是相当于一个类的实例的指针，this是用来操作对象实例的内容的，既然静态成员函数和变量都是独立于类的实例对象之外的，他就不能用this指针。也不能操作非静态成员。

### 虚函数

```C++
/*BrassPlus 是 Brass 的子类， ViewAcct() 是两个类中都有的方法。
由于 bp是父类指针，如果基类不用虚方法那么就会调用基类的 ViewAcct() 方法
若如果在基类中将 ViewAcct() 声明为虚，则 bp->ViewAcct() 根据对象类型（BrassPlus）调用 BrassPlue::ViewAcct()方法*/
BrassPlus ophelia;
Brass * bp;
bp = &ophelia;
bp->ViewAcct();  // 是调用子类还是父类的 ViewAcct() 方法？
```
【CPP 503】

#### [虚函数是否可以内联](https://www.yuque.com/huihut/interview/readme#ikirca)

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

### 虚析构函数
```C++
// Employee 是基类，Singer 是派生类
Employee *pe = new Singer;
...
delete pe;  // ~Employee() or ~Singer()?
```
如果基类中的析构函数不是虚的，就只调用对应于指针类型(Employee)的析构函数，但实际中，是想调用派生类的析构函数。如果基类的析构函数是虚的，将调用相应对象类型(Singer)的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以保证正确的析构函数序列被调用。
【CPP501，505】

### 静态联编和动态联编
将源程序中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中由于不支持函数重载，这很容易，在C++中，由于支持函数重载，编译器必须查看函数的参数才知道调用的是哪一个函数。C++在编译过程中就可以完成这种联编，故称为静态联编，又称为早期联编。编译器总是对非虚方法使用静态联编。

然而虚函数使编译器不知道在编译时到底用哪一个函数，因为编译器不知道用户将选择哪种类型的对象，所以编译器必须生成能够在程序运行时选择正确的虚函数的代码，这被称之为动态联编，也被称为晚期联编。
【CPP501】

### 有关虚函数的注意事项
- 构造函数不能是虚函数。先构造父类对象，然后才能是子类对象，如果构造函数设为虚函数，那么当你在构造父类的构造函数时就不得不显示的调用构造，还有一个原因就是为了防错，试想如果你在子类中一不小心重写了个跟父类构造函数一样的函数，那么你的父类的构造函数将被覆盖,也即不能完成父类的构造，就会出错。 
- 析构函数应当是虚函数，除非类不用做基类。即使类不用作基类，通常应给基类提供一个虚析构函数
- 友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数
- 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本
- 如果派生类重新定义函数，将隐藏同名基类方法，这不同于重载
【CPP503，504】

### 纯虚函数

纯虚函数是一种特殊的虚函数，纯虚函数只是一个接口，是让派生类实现细节的，在纯虚函数中也可以定义具体实现，但没意义。包含纯虚函数的类是抽象基类（ABC，abstract base class），它只能作为基类，不能创建对象。可以从抽象基类派生出具体类（普通类），这些类可以创建对象。
```C++
class C
public:
	virtual int f1() = 0;  //函数原型中的 =0 使虚函数成为纯虚函数
	virtual double area() const = 0;  
	virtual ~C() {}
```
【CPP509，510】

### 虚函数、纯虚函数
- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。

### 类型安全

类型安全是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据是用类型来解释的)。

Java语言是类型安全的，除非强制类型转换。

C语言不是类型安全的，因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1，用boolean来解释就是true。

C++ 也不是绝对类型安全的，但使用得当，它将远比C更有类型安全性。

**C++提供了一些新的机制保障类型安全：**

- 操作符new返回的指针类型严格与对象匹配，而不是void
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
- C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

[什么是类型安全](https://blog.csdn.net/a3192048/article/details/82499164)