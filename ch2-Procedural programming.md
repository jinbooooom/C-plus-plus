## 面向过程的编程风格

### 指针(pointer)与引用(reference)

```C++
ing ival = 1024;
int *pi = &ival;  // pointer
int &rval = ival;  // reference
```

- 引用是别名，而指针是地址。指针可以被赋值，以指向另一个不同的对象，而引用总是指向在初始化时被指定的对象，以后不能修改，但引用的那个对象内容却可以改变。可以把引用理解为指针常量，而普通指针为指针变量。
- 从内存分配上来看，程序为指针变量分配内存区域，而不为引用分配内存区域。
- 在使用上，指针可能（也可能不）指向一个对象，提领时一定要先确定其值非 0。而引用，则必定会代表某个对象，所以不需要作此检查。

【ESC 46，47】

### 作用域与生存周期

c++ 变量有两个属性非常重要：作用域和生存周期。

一个程序将操作系统分配各其运行的内存块分为4个区域：

- 静态区（全局区）：存放程序的全局变量和静态变量。初始化的全局变量和静态变量在一个区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

- 堆区：存放程序的动态数据。

- 栈区：存放程序的局部数据，即各个函数中参数和局部变量等。函数结束，自动释放。

- 文字常量区：常量字符串就是放在这里，程序结束后由系统释放。

- 代码区：存放程序的代码，即程序中的各个函数代码块。

```c++
int a = 0; //全局初始化区
char *p1;  //全局未初始化区
int main() 
{
    int b;    //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456";  //123456\0在常量区，p3在栈上。
    static int c = 0;  //全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);  //分配得来的10和20字节的区域就在堆区。
    strcpy(p1, "123456");  //123456\0放在文字常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
}
```

[[C/*C++内存*分配](https://zhuanlan.zhihu.com/p/82298443)](https://zhuanlan.zhihu.com/p/82298443)

#### 局部变量和全局变量

局部变量也称为内部变量，它是在函数内定义的。其作用域仅限于函数内，离开该函数后再使用这种变量是非法的。

全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。在函数内部，局部变量可以屏蔽全局变量。如果一个全局变量用 static 修饰，它就是静态全局变量，它的作用域是该文件范围（称为文件作用域）

#### 静态存储与动态存储

变量的生存周期只与变量的存储位置（存储类别）有关。可以分为：

- 静态存储方式（在程序运行期间，系统对变量分配**固定的**存储空间）
- 动态存储方式（在程序运行期间，系统对变量动态（**不固定**）的分配存储空间）

而变量的存储类别可以分为静态存储和动态存储
- auto  自动变量(动态存储方式) 
- static 静态变量(静态存储方式)  
-  register 寄存器变量(动态存储方式) 
- extern 外部变量(静态存储方式) 

[【c++】变量的作用域和生存周期](https://blog.csdn.net/u012679707/article/details/80188124)

#### C++变量保存在堆还是栈？
- 如果对象是函数内的非静态局部变量，则对象，对象的成员变量保存在栈区。
- 如果对象是全局变量，则对象，对象的成员变量保存在静态区。
- 如果对象是函数内的静态局部变量，则对象，对象的成员变量保存在静态区。
- 如果对象是new出来的，则对象，对象的成员变量保存在堆区。
```C++
void foo() {
    int* p = new int[5]; 
}
//在栈内存中存放了一个指向一块堆内存的指针p。
//在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，
//然后返回这块内存的首地址，放入栈中
```
[C/C++堆、栈及静态数据区详解](https://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html)

### new 与 delete

堆内存（空闲空间）里的内存分配通过 new 表达式来完成，释放通过 delete 表达式来完成。堆内存由程序员自行管理。

```C++
int *p1 = new int;  // 未初始化
int *p2 = new int(1024); // 指定初值, p2 指向一个 int 对象，其值为 1024
int *p3 = new int[1024]; // 从 heap 中分配一个数组，含有1024个元素，p3 指向数组第一个元素
delete p1;
delete p2;  //  对于普通数据类型， delete p 与 delete [] p 作用效果一样。
delete [] p3  // 复杂对象，必须用 delete [] p 来释放内存
// 如果不使用 delete，由 heap 分配而来的对象就永远不会被释放，这被称之为内存泄漏。
```

【ESC 49，50】

### 返回引用与返回值

[返回指针引用示例](https://blog.csdn.net/selina8921/article/details/79763169)

### 函数指针数组

```C++
const vector<int>* (*seq_array[])(int) = {
    fibon_seq, lucas_seq, pell_seq,
    triang_seq, square_seq, pent_seq
};
```

seq_array 是一个可以持有六个函数指针的指针数组，第一个元素指向函数 fibon_seq()，该函数原型为 `const vector<int> *fibon_seq(int);`。

【ESC 62】

### 头文件

- 头文件的扩展名习惯上是.h，标准库例外。
- 函数的定义只能有一份，倒是可以有多份声明。我们不能把函数的定义放在头文件，因为一个程序的多个代码文件可能都会包含这个头文件。但只定义一份的规则有一个例外，内联函数。为了能够扩展内联函数的内容，以便在每个调用点上，编译器都取得其定义，必须将内联函数的定义放在头文件中，而不是放在各个不同程序代码文件中。
- 一个对象和变量同函数一样，也只能在程序中定义一次，因此也应该将定义放在程序代码文件中，而不是头文件中。一般地，加上 extern 就可以放在头文件中作为声明了。
```C++
//如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量
extern int x;  //声明x而非定义
int y;         //声明并定义y
```
- `const int a = 6;`就可以放入头文件中，因为 const object 就和 inline 函数一样，是”一次定义“规则下的例外。因为 const 定义一出文件外便不可见（文件作用域），这意味着可以在多个不同的文件中加以定义。
-  头文件用 <> 表明此文件被认为是标准的或项目专属的头文件，编译器搜索此文件时，会先在系统默认的磁盘目录下寻找；头文件用 ” “ 表明此文件被认为是用户提供的头文件，会先在包含此文件的磁盘目录开始寻找，找不到再去系统默认的目录下寻找。

【ESC 63，64】

